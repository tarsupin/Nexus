
Scene Architecture:
	
	The Scene Loop for dealing with Objects also handles:
		- Running all Update() methods.
		- Adds all objects to Collision Map for this frame.
			- Assigns sectors, etc.
			- Anything not seen doesn't need to be added to collision map.
	
	Each object's Update() method handles:
		- Tile collisions.
		- If resting, don't run gravity.

	Tracking:
		`objects`				Dictionary<ObjectGroup, Dictionary <Object ID, Object>>		// Need ObjectGroup for Rendering and Fast Loading
		`objectClasses`			Dictionary <Class ID, Object>
		`tilemap`				Tilemap
		
	(( Note: Objects in Scene Tracking don't add collision detection if they have a tile setting attached to them. ))

	CharCollide Objects: Objects that collide only with Characters.
		- e.g. Collectables, Doors, Chests, Portals, Keys, Coins, etc.
		- Tracked with `charOnlyObjects` in the scene.
		- These will not get loaded into the collision pools with other objects.
		- Characters will test for CharCollide objects in their proximity.
		- Eliminates (guess) 30% of all collision actors.

	Decor Objects: Objects that are only rendered; have no updates or collision mechanics.
		- Loaded into `decormap` in the Scene; similar to tilemap, but is exclusively for rendering.
		- Rendered, but otherwise ignored for all other scene-critical loops.
		- Eliminates (guess) 20% of object listings.

	Tile Objects: Objects that are added into the Tilemap; not tracked in `objects`; Rendered, Passive Collision.
		- These are acted upon during TileCollision steps by Dynamic Objects, but not added to collision suites.

	Pseudo-Tile Objects: Have an `objects` entry, but Passive Collision through tilemap. No active collision mapping.

	Dynamic Objects: Objects with Update, Render, and Collision.
	Static Objects: Objects that are not Tile. Have Render and Collision.

	Critical Properties:
		.activity
			= Intangible	// Cannot change from this state. Has no Update() or Render() behavior.
			= Unseen		// Does not Update() or Render()
			= Seen			// A non-Self player has seen it. Will run the Update() method, but not Render().
			= SeenSelf		// Self Player has seen it. Will run Update() and Render().
			= ForceActive	// Always runs Update(), even when not visible. Does not return to Unseen.
		.collision
			.colType		// None (No Collision), ActiveCollide, GridCollide (Tile-Triggered), CharCollide (Collides only with Character)
							// If GridCollide is set, don't add to the collision map; only trigger in reaction to tile/static collision detections.
			.resting		// TRUE = is resting on a tile; don't run gravity effects until acted upon. FALSE = is not resting on tile.

	Seen / Activity Cycles:
		Every 30th frame, run an activity cycle:
			- All objects with .activity == Seen or SeenSelf gets set to Unseen.
			- Immediately assign any new objects visible by characters to Seen or SeenSelf.

Tilemap Architecture:		
	
	Tilemap Component: Should be its own class, entirely self-contained, so that it can be swapped out at any time.
		- Only have one .data source for the tilemap; not separate for background, foreground, etc.
		- Only need to loop through once, since we track it with the boolean array.

	The Level Data Architecture:
		.main (contains all bg tiles; includes main tiles that fill up all slots)
		.fg (contains all fg tiles; decor, prompts, etc)
		.obj (contains all objects, which are identified differently than tiles)

	The Game Mapper Enums:
		- Tiles
		- FG Tiles
		- Objects

Layering / Render Order:
	
	Render Order:
		- Tiles are rendered first.
		- Tiles have a background and foreground render (prompts, etc).

		- After tiles, certain orders are relevant:
			- Platform
			- Enemies
			- Items
			- Trailing Items
			- Character
			- Projectiles

		// MonoGame can handle this with SpriteSortMode.BackToFront -- we will need to adjust the Draw() instructions to do this.
		SpriteBatch.Begin (SpriteSortMode.BackToFront, BlendState)

Collision Terminology:
	
	Collisions:
		RoomX: 1440 pixel wide columns across the level (Room 0 would be 0 to 1440).
		RoomY: 1400 pixel tall rows across the level.
		SectorX: (1440/5) 288 pixel wide columns across the level. (Sector 0 would be 0 to 288)
		SectorY: (1440/5) 288 pixel tall rows across the level.
		TileX: (288/6) 48 pixels wide.
		TileY: (288/6) 48 pixels tall.
	
	Collision Rules:
		Ignore.Dynamic
		Ignore.Static
		Ignore.Collectables
		...

	CollideSequence
		- The class that handles collision each frame.
		- Identifies sectors, identifies where items are that can collide, etc.
		- Culls any that aren't seen.
		- Determines what objects are nearby.
		- Determines what objects are overlapping.
		- Processes collisions.

	CollideBroad
		- A Broad-Phase Detection System, as a component.
		- Keeping this as a separate component will allow us to swap it out and test memory / speed vs. others.
		- Options: Tile-Based AABB-ish? Sector-Based? Quad? Other? Sweep and ...?

		Sector-Based:
			Identify SectorZ: SectorX+SectorY*200;
			Sector[z] = [...objects]
			Pass objects to CollideNarrow for further detection.
	
		Vertical-Based (2-Tile Size):
			

	CollideNarrow
		- A Narrow-Phase Detection System, as a component.
		- Detects if two objects are overlapping.
		- Detects direction that objects overlap or intersect.
	
	ColReact{TYPE}
		- Handles the effects and reactions of collisions between objects.
	
	Touch{TYPE}
		- Component for a Game Object.
		- Assigns parameters for the object, such as solidity, etc.
	
	CollideMap
		- Directs to ColReact{Type} classes.

Collision Optimization:
	Use ArrayPool optimizations.
	Test against all other objects in sector, but eliminate first steps each cycle to avoid repeat test.
	

Players:
	Player - A generic term for any player: Self, Bot, or Playmate.
	Self - The active player, the one controlling the program directly.
	Bot - A simulated player; has pre-programmed inputs.
	Playmate - Another player, but one that is controlled through multiplayer.


Input Process:
	
	Players create input through Keyboard and GamePads.

	Input client processes the inputs.
		- Maps the keys and gamepad to actions.
		- Translates the inputs.

	LocalServer receives the inputs.
		- Decides whether or not to send to actual server (for multiplayer) or remain local.
		- If sending to server, additional step for converting packets is handled.
			- LocalServer converts input into ClientInputPacket.
			- LocalServer receives ServerInputPacket.
			- LocalServer interprets ServerInputPackets recieved.
	
	LocalServer sends inputs to GameRoom.

	GameRoom sends inputs to Scene.


OBSOLETE / OUTDATED (NEEDS REVISION) Input Process:
	
	Players create input through Keyboard and GamePads.

	InputClient processes the information, which is separate from the simulation ticks.
		- Maps the keys and gamepad to actions.
		- Translates the inputs.

		PacketFromClient prepares a packet for IKeys
	
	FOR MULTIPLAYER:

		InputClient sends the IKey Packet to Socket

		Socket sends IKey Packet to Server

		Server Hub Receives IKey Packet
			- Interprets instruction.
			- Determines which room/hub to send to.
			- Sends Packet to Room

		Server Room receives IKey Packet
			- Interprets instruction.
			- Updates player inputs by frame.
	
		Server Packet creates InputPacket to return to Clients

		Server Room sends InputPacket to Clients

	FOR SINGLE PLAYER:

	Clients receive InputPacket
		- Routes to RoomClient.HandleInput

	RoomClient.HandleInput receives InputPacket
		- Determines that it is an InputPacket.
		- Interprets InputPacket
		- Delivers Packet to Scene

	Scene Receives Input Packet Decoded
		- Interprets IKeys for each player.
		- Updates player IKeyStates for assigned frame.
	
	Simulation Runs, using IKeyStates from each player on each frame assigned.
		
