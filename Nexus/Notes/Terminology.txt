
Scene Architecture:
	
	The Scene Loop for dealing with Objects also handles:
		- Running all Update() methods.
		- Adds all objects to Collision Map for this frame.
			- Assigns sectors, etc.
			- Anything not seen doesn't need to be added to collision map.
	
	Each object's Update() method handles:
		- Tile collisions.
		- If resting, don't run gravity.

	Tracking:
		`objects`				Dictionary <Object ID, Object>
		`charOnlyObjects`		Tilemap of some sort?
		`tilemap`				Tilemap
		
	(( Note: Objects in Scene Tracking don't add collision detection if they have a tile setting attached to them. ))

	CharCollide Objects: Objects that collide only with Characters.
		- e.g. Collectables, Doors, Chests, Portals, Keys, Coins, etc.
		- Tracked with `charOnlyObjects` in the scene.
		- These will not get loaded into the collision pools with other objects.
		- Characters will test for CharCollide objects in their proximity.
		- Eliminates (guess) 30% of all collision actors.

	Decor Objects: Objects that are only rendered; have no updates or collision mechanics.
		- Loaded into `decormap` in the Scene; similar to tilemap, but is exclusively for rendering.
		- Rendered, but otherwise ignored for all other scene-critical loops.
		- Eliminates (guess) 20% of object listings.

	Tile Objects: Objects that are added into the Tilemap; not tracked in `objects`; Rendered, Passive Collision.
		- These are acted upon during TileCollision steps by Dynamic Objects, but not added to collision suites.

	Pseudo-Tile Objects: Have an `objects` entry, but Passive Collision through tilemap. No active collision mapping.

	Dynamic Objects: Objects with Update, Render, and Collision.
	Static Objects: Objects that are not Tile. Have Render and Collision.

	Critical Properties:
		.activity
			= Intangible	// Cannot change from this state. Has no Update() or Render() behavior.
			= Unseen		// Does not Update() or Render()
			= Seen			// A non-Self player has seen it. Will run the Update() method, but not Render().
			= SeenSelf		// Self Player has seen it. Will run Update() and Render().
			= ForceActive	// Always runs Update(), even when not visible. Does not return to Unseen.
		.collision
			.colType		// None (No Collision), ActiveCollide, GridCollide (Tile-Triggered), CharCollide (Collides only with Character)
							// If GridCollide is set, don't add to the collision map; only trigger in reaction to tile/static collision detections.
			.resting		// TRUE = is resting on a tile; don't run gravity effects until acted upon. FALSE = is not resting on tile.

	Seen / Activity Cycles:
		Every 30th frame, run an activity cycle:
			- All objects with .activity == Seen or SeenSelf gets set to Unseen.
			- Immediately assign any new objects visible by characters to Seen or SeenSelf.

Tilemap Architecture:		
	
	Tilemap Component: Should be its own class, entirely self-contained, so that it can be swapped out at any time.
		- Only have one .data source for the tilemap; not separate for background, foreground, etc.
		- Only need to loop through once, since we track it with the boolean array.

	The Level Data Architecture:
		.main (contains all bg tiles; includes main tiles that fill up all slots)
		.fg (contains all fg tiles; decor, prompts, etc)
		.obj (contains all objects, which are identified differently than tiles)

	The Game Mapper Enums:
		- Tiles
		- FG Tiles
		- Objects

	Optimizing the Tilemap:
		- Use a bool 2d multi-array to identify any tilemap squares that are filled.
		- Use a dictionary <ushort, new object[] PARAMS> to reference what exists at the tile.
			- params = { tileType, fg_bg_options, textureString }

		bool[,] tilemap = new bool[gridYCount, gridXCount];

	parameter; tileType enum:
		0 = standard tile with full collision (ground, boxes, etc)
		1 = bg tile, decor, no collision
		2 = fg tile, prompt, no collision
		3 = bg and fg tiles, 
		4 = special; point to object ID, the tile will be generated

	parameter collisionType enum:
		0 = no collision
		1 = full collision
		2 = ledge collision

	It's possible for a tile instruction to include a "Point to Object ID" setting.
		- In which case, the tile is an actual object in the scene; must interact with it accordingly.
		- charOnly tiles behave in this way. They render, and can be touched by character during static tests.
		- could also have enemyOnly, etc... many possibilities here.

Collision Terminology:
	
	Collisions:
		RoomX: 1440 pixel wide columns across the level (Room 0 would be 0 to 1440).
		RoomY: 1400 pixel tall rows across the level.
		SectorX: (1440/5) 288 pixel wide columns across the level. (Sector 0 would be 0 to 288)
		SectorY: (1440/5) 288 pixel tall rows across the level.
		TileX: (288/6) 48 pixels wide.
		TileY: (288/6) 48 pixels tall.
	
	Collision Rules:
		Ignore.Dynamic
		Ignore.Static
		Ignore.Collectables
		...

	CollideSequence
		- The class that handles collision each frame.
		- Identifies sectors, identifies where items are that can collide, etc.
		- Culls any that aren't seen.
		- Determines what objects are nearby.
		- Determines what objects are overlapping.
		- Processes collisions.

	CollideBroad
		- A Broad-Phase Detection System, as a component.
		- Keeping this as a separate component will allow us to swap it out and test memory / speed vs. others.
		- Options: Tile-Based AABB-ish? Sector-Based? Quad? Other? Sweep and ...?

		Sector-Based:
			Identify SectorZ: SectorX+SectorY*200;
			Sector[z] = [...objects]
			Pass objects to CollideNarrow for further detection.
	
		Vertical-Based (2-Tile Size):
			

	CollideNarrow
		- A Narrow-Phase Detection System, as a component.
		- Detects if two objects are overlapping.
		- Detects direction that objects overlap or intersect.
	
	ColReact{TYPE}
		- Handles the effects and reactions of collisions between objects.
	
	Touch{TYPE}
		- Component for a Game Object.
		- Assigns parameters for the object, such as solidity, etc.
	
	CollideMap
		- Directs to ColReact{Type} classes.

Collision Optimization:
	Use ArrayPool optimizations.
	Test against all other objects in sector, but eliminate first steps each cycle to avoid repeat test.
	

Players:
	Player - A generic term for any player: Self, Bot, or Playmate.
	Self - The active player, the one controlling the program directly.
	Bot - A simulated player; has pre-programmed inputs.
	Playmate - Another player, but one that is controlled through multiplayer.


Input Process:
	
	Players create input through Keyboard and GamePads.

	InputClient processes the information, which is separate from the simulation ticks.
		- Maps the keys and gamepad to actions.
		- Translates the inputs.

	PacketFromClient prepares a packet for IKeys
	
	InputClient sends the IKey Packet to Socket

	Socket sends IKey Packet to Server

	Server Hub Receives IKey Packet
		- Interprets instruction.
		- Determines which room/hub to send to.
		- Sends Packet to Room

	Server Room receives IKey Packet
		- Interprets instruction.
		- Updates player inputs by frame.
	
	Server Packet creates a RoomPacket to return to Clients

	Server Room sends RoomPacket to Clients

	Clients receive RoomPacket

	ClientRoom receives RoomPacket
		- Interprets IKeys toggled for every player.
		- Updates player IKeyStates
	
	Simulation Runs, using IKeyStates from each player.
		
