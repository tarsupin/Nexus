
Scene Architecture:
	
	The Scene Loop for dealing with Objects also handles:
		- Running all Update() methods.
		- Adds all objects to Collision Map for this frame.
			- Assigns sectors, etc.
			- Anything not seen doesn't need to be added to collision map.
	
	Each object's Update() method handles:
		- Tile collisions.
		- If resting, don't run gravity.

	Tracking:
		`objects`				Dictionary<ObjectGroup, Dictionary <Object ID, Object>>		// Need ObjectGroup for Rendering and Fast Loading
		`objectClasses`			Dictionary <Class ID, Object>
		`tilemap`				Tilemap
		
	(( Note: Objects in Scene Tracking don't add collision detection if they have a tile setting attached to them. ))

	CharCollide Objects: Objects that collide only with Characters.
		- e.g. Collectables, Doors, Chests, Portals, Keys, Coins, etc.
		- Tracked with `charOnlyObjects` in the scene.
		- These will not get loaded into the collision pools with other objects.
		- Characters will test for CharCollide objects in their proximity.
		- Eliminates (guess) 30% of all collision actors.

	Decor Objects: Objects that are only rendered; have no updates or collision mechanics.
		- Loaded into `decormap` in the Scene; similar to tilemap, but is exclusively for rendering.
		- Rendered, but otherwise ignored for all other scene-critical loops.
		- Eliminates (guess) 20% of object listings.

	Tile Objects: Objects that are added into the Tilemap; not tracked in `objects`; Rendered, Passive Collision.
		- These are acted upon during TileCollision steps by Dynamic Objects, but not added to collision suites.

	Pseudo-Tile Objects: Have an `objects` entry, but Passive Collision through tilemap. No active collision mapping.

	Dynamic Objects: Objects with Update, Render, and Collision.
	Static Objects: Objects that are not Tile. Have Render and Collision.

	Critical Properties:
		.activity
			= Intangible	// Cannot change from this state. Has no Update() or Render() behavior.
			= Unseen		// Does not Update() or Render()
			= Seen			// A non-Self player has seen it. Will run the Update() method, but not Render().
			= SeenSelf		// Self Player has seen it. Will run Update() and Render().
			= ForceActive	// Always runs Update(), even when not visible. Does not return to Unseen.
		.collision
			.colType		// None (No Collision), ActiveCollide, GridCollide (Tile-Triggered), CharCollide (Collides only with Character)
							// If GridCollide is set, don't add to the collision map; only trigger in reaction to tile/static collision detections.
			.resting		// TRUE = is resting on a tile; don't run gravity effects until acted upon. FALSE = is not resting on tile.

	Seen / Activity Cycles:
		Every 30th frame, run an activity cycle:
			- All objects with .activity == Seen or SeenSelf gets set to Unseen.
			- Immediately assign any new objects visible by characters to Seen or SeenSelf.

Tilemap Architecture:		
	
	Tilemap Component: Should be its own class, entirely self-contained, so that it can be swapped out at any time.
		- Only have one .data source for the tilemap; not separate for background, foreground, etc.
		- Only need to loop through once, since we track it with the boolean array.

	The Level Data Architecture:
		.main (contains all bg tiles; includes main tiles that fill up all slots)
		.fg (contains all fg tiles; decor, prompts, etc)
		.obj (contains all objects, which are identified differently than tiles)

	The Game Mapper Enums:
		- Tiles
		- FG Tiles
		- Objects

Layering / Render Order:
	
	Render Order:
		- Tiles are rendered first.
		- Tiles have a background and foreground render (prompts, etc).

		- After tiles, certain orders are relevant:
			- Platform
			- Enemies
			- Items
			- Trailing Items
			- Character
			- Projectiles

		// MonoGame can handle this with SpriteSortMode.BackToFront -- we will need to adjust the Draw() instructions to do this.
		SpriteBatch.Begin (SpriteSortMode.BackToFront, BlendState)

Collision Terminology:
	
	TilemapEnum:
		SectorLargeX: 1440 pixel wide columns across the level (Room 0 would be 0 to 1440).
		SectorLargeY: 1400 pixel tall rows across the level.
		SectorXPixels: (1440/5) 288 pixel wide columns across the level. (Sector 0 would be 0 to 288)
		SectorYPixels: (1440/5) 288 pixel tall rows across the level.
		TileWidth: (288/6) 48 pixels wide.
		TileHeight: (288/6) 48 pixels tall.
	
	Collision Rules:
		Ignore.Dynamic
		Ignore.Static
		Ignore.Collectables
		...

	CollideSequence
		- The class that handles collision each frame.
		- Identifies sectors, identifies where items are that can collide, etc.
		- Culls any that aren't seen.
		- Determines what objects are nearby.
		- Determines what objects are overlapping.
		- Processes collisions.

	CollideBroad
		- A Broad-Phase Detection System, as a component.
		- Keeping this as a separate component will allow us to swap it out and test memory / speed vs. others.
		- Options: Tile-Based AABB-ish? Sector-Based? Quad? Other? Sweep and ...?

		Sector-Based:
			Identify SectorZ: SectorX+SectorY*200;
			Sector[z] = [...objects]
			Pass objects to CollideNarrow for further detection.
	
		Vertical-Based (2-Tile Size):

	CollideNarrow
		- A Narrow-Phase Detection System, as a component.
		- Detects if two objects are overlapping.
		- Detects direction that objects overlap or intersect.
	
	ColReact{TYPE}
		- Handles the effects and reactions of collisions between objects.
	
	Touch{TYPE}
		- Component for a Game Object.
		- Assigns parameters for the object, such as solidity, etc.
	
	CollideMap
		- Directs to ColReact{Type} classes.

Collision Optimization:
	Use ArrayPool optimizations.
	Test against all other objects in sector, but eliminate first steps each cycle to avoid repeat test.
	

Players:
	Player - A generic term for any player: Self, Bot, or Playmate.
	Self - The active player, the one controlling the program directly.
	Bot - A simulated player; has pre-programmed inputs.
	Playmate - Another player, but one that is controlled through multiplayer.


Input Process:
	
	Players create input through Keyboard and GamePads.

	InputClient processes the inputs.
		- Maps the keys and gamepad to actions.
		- Translates the inputs.

	LocalServer receives the inputs.
		- Decides whether or not to send to actual server (for multiplayer) or remain local.
		- If sending to server, additional step for converting packets is handled.
			- LocalServer converts input into ClientInputPacket.
			- LocalServer receives ServerInputPacket.
			- LocalServer interprets ServerInputPackets recieved.
	

Simulation Process:
	
	On every frame, attempt to get the "true" simulation frame.


Server Instructions for New Scene:

	1. Create a New Scene		// SceneTransition, Load Content, etc.
	2. Wait for Connections		// A polite pause while others are loading.
	3. "Begin" Instruction		// Signals frame 0, begins allowing input to matter.
	4. New Frames ASAP			// Continues sending every next frame as soon as possible.

